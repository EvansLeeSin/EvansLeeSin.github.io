---
title: 反射的使用
date: 2024-07-23 16:27:58
tags: Java
---

![img](https://www.pdai.tech/images/java/java-basic-reflection-3.png)

### 反射的使用

在反射包中，常用的类主要有

- Constructor类表示的是Class对象所表示的类的构造方法，利用它可以动态的创建对象。
- Field表示Class对象所表示的成员变量，通过它可以在运行时修改成员变量的属性值(包含private)
- Method表示Class中的成员方法，通过它可以动态的调用对象的方法(包含private)

#### Class类对象的获取

```java
    @Test
    public void classTest() throws Exception {
        // 获取Class对象的三种方式
        logger.info("根据类名:  \t" + User.class);
        logger.info("根据对象:  \t" + new User().getClass());
        logger.info("根据全限定类名:\t" + Class.forName("com.test.User"));
        // 常用的方法
        logger.info("获取全限定类名:\t" + userClass.getName());
        logger.info("获取类名:\t" + userClass.getSimpleName());
        logger.info("实例化:\t" + userClass.newInstance());
    }
```

#### 获取构造器

`getDeclaredConstructor()`和`getConstructor()`方法相同，区别是后者只返回public修饰符的构造器

下面对以上方法进行举例

```java
getDeclaredConstructor();//获取类的无参构造
```

```java
Class[] p = {int.class,String.class};
getDeclaredConstructor(p);//取有两个参数分别为int和String类型的构造方法
```

```Java
Constructor[] constructors;//创建一个构造器的数组
constructors = c1.getDeclaredConstructors();//获取所有的构造器放在数组里
```

`getConstructor()`方法和以上同理，只不过在获取有参构造时，如果**不是public修饰**的构造，获取时会**报错**

使用：构造器Constructor.newInstance(有参/无参)       Class本身也有newInstance方法，只不过只能调用其默认无参构造

#### 获取字段

- `Class.getDeclaredField(String name)和Class.getDeclaredFields()`都是获取的包括private的字段
- `Class.getField(String name)`和`Class.getFields()`只返回public修饰的字段

以上都是返回的Field类型的数据，那么获取字段的值，需要`get(Object obj)`的方法，且如果是private对象，那么必须先设置Accessible为true才能获取,看下小代码块

```java
Field f1 = person.getClass().getDeclaredField("name");
f1.setAccessible(true);
f1.get(person);
```

#### 获取方法

获取方法的方式和上面差不多 这边直接上栗子

```java
public class MethodTypeSpy extends BaseTestClass {
    private static final String fmt = "%24s:   %s\n";

    @Deprecated
    public static void main(String[] args) throws ClassNotFoundException {
        MethodTypeSpy methodTypeSpy = new MethodTypeSpy();
        Class<? extends MethodTypeSpy> cls = methodTypeSpy.getClass();
        printFormat("Class：%s \n", cls.getCanonicalName());//输出更容易理解的getName()
        Method[] declaredMethods = cls.getDeclaredMethods();//获取该类的方法数组
        for (Method declaredMethod : declaredMethods) {
            printFormat(fmt, "Method name", declaredMethod.getName());  //获得单独的方法名
            //获得完整的方法信息（包括修饰符、返回值、路径、名称、参数、抛出值）
            printFormat(fmt, "toGenericString", declaredMethod.toGenericString());

            int modifiers = declaredMethod.getModifiers();      //获得修饰符
            printFormat(fmt, "Modifiers", Modifier.toString(modifiers));

            System.out.format(fmt, "ReturnType", declaredMethod.getReturnType());   //获得返回值
            System.out.format(fmt, "getGenericReturnType", declaredMethod.getGenericReturnType());//获得完整信息的返回值

            Class<?>[] parameterTypes = declaredMethod.getParameterTypes(); //获得参数类型
            Type[] genericParameterTypes = declaredMethod.getGenericParameterTypes();
            for (int i = 0; i < parameterTypes.length; i++) {
                System.out.format(fmt, "ParameterType", parameterTypes[i]);
                System.out.format(fmt, "GenericParameterType", genericParameterTypes[i]);
            }

            Class<?>[] exceptionTypes = declaredMethod.getExceptionTypes();     //获得异常名称
            Type[] genericExceptionTypes = declaredMethod.getGenericExceptionTypes();
            for (int i = 0; i < exceptionTypes.length; i++) {
                System.out.format(fmt, "ExceptionTypes", exceptionTypes[i]);
                System.out.format(fmt, "GenericExceptionTypes", genericExceptionTypes[i]);
            }

            Annotation[] annotations = declaredMethod.getAnnotations(); //获得注解
            for (Annotation annotation : annotations) {
                System.out.format(fmt, "Annotation", annotation);
                System.out.format(fmt, "AnnotationType", annotation.annotationType());
            }
        }
    }
}
```

输出的结果

```java
Class：net.sxkeji.shixinandroiddemo2.test.reflection.MethodTypeSpy 
             Method name:   main
         toGenericString:   public static void net.sxkeji.shixinandroiddemo2.test.reflection.MethodTypeSpy.main(java.lang.String[]) throws java.lang.ClassNotFoundException
               Modifiers:   public static
              ReturnType:   void
    getGenericReturnType:   void
           ParameterType:   class [Ljava.lang.String;
    GenericParameterType:   class [Ljava.lang.String;
          ExceptionTypes:   class java.lang.ClassNotFoundException
   GenericExceptionTypes:   class java.lang.ClassNotFoundException
              Annotation:   @java.lang.Deprecated()
          AnnotationType:   interface java.lang.Deprecated

Process finished with exit code 0
```

#### 执行方法

使用`java.lang.reflect.Method.invoke()`方法来反射调用一个方法

```java
//invoke需要传两个参数，第一个参数传方法属于的对象(静态方法可传null)
//第二个可变参数是该方法的参数
public interface MethodAccessor {
    Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException;
}
```

第二个参数其实是Class类型的可变参数，里面放形参类型的Class(按照声明的顺序)

```java
//无参
private Integer show() {
    return 1;
}
//有参
public void showInteger(Integer i) {
    this.i = i;
}
//可变参数
public void printVarArgs(String... varArgs) {
    for (String arg : varArgs) {
        System.out.format("%20s\n", arg);
    }
}

//获取方法的方式
public static void main(String[] args){
    ClassDemo cls = new ClassDemo();
    Class c = cls.getClass();
    try{
        Method m = c.getDeclaredMethod("show",null);//无参获取
        Class[] cArg = new Class[1];
        cArg[0] = Integer.class;
        Method mArg = c.getDeclaredMethod("showInateger",cArg);//有参数需要传Class数组
        mArg.invoke(cls,new Integer(1));//调用有参方法
        Method mArgs = c.getDeclaredMethod("printVarArgs",String[].class);//可变参数类型直接传类型Class数组
        String[] varArgs = {"evans","lee"};
        mArgs.invoke(cls,(Object)varArgs);//调用方法
    }
}

```

